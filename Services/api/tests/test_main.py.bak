import pytest
from fastapi.testclient import TestClient
import pytest
from sqlalchemy.orm import Session, sessionmaker
from sqlalchemy import create_engine
from sqlmodel import SQLModel
from fastapi.testclient import TestClient
from typing import Generator
from app.main import app
from app.database import get_session
from app.models import RiskAssessment  # Import the model

# Use in-memory SQLite for testing with thread-safe check_same_thread=False
TEST_DATABASE_URL = "sqlite:///:memory:"
engine = create_engine(
    TEST_DATABASE_URL, 
    connect_args={"check_same_thread": False}
)

@pytest.fixture(scope="session", autouse=True)
def setup_database():
    # Create the RiskAssessment table explicitly
    Base = SQLModel.metadata
    if not Base.tables:  # If tables haven't been registered yet
        RiskAssessment.__table__
    Base.create_all(bind=engine)
    yield
    Base.drop_all(bind=engine)

@pytest.fixture(scope="session")
def test_session_local():
    SessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=False)
    return SessionLocal

@pytest.fixture
def db_session(test_session_local) -> Generator[Session, None, None]:
    session = test_session_local()
    try:
        yield session
    finally:
        session.close()

def override_get_session(db_session: Session = None):
    def get_test_session():
        try:
            yield db_session
        finally:
            pass  # Session is handled by the fixture
    return get_test_session

@pytest.fixture
def test_client(db_session):
    app.dependency_overrides[get_session] = override_get_session(db_session)
    # Ensure database tables are created
    Base = SQLModel.metadata
    if not Base.tables:
        RiskAssessment.__table__
    Base.create_all(bind=engine)
    with TestClient(app) as client:
        yield client
    app.dependency_overrides.clear()

# Tests
def test_health_endpoint(test_client: TestClient):
    response = test_client.get("/health")
    assert response.status_code == 200
    assert response.json() == {"status": "healthy"}

def test_risk_score_endpoint(test_client: TestClient, db_session: Session):
    test_request = {
        "entity_name": "Test Corp",
        "risk_factors": ["industry", "location"],
        "context": "Test context"
    }
    response = test_client.post("/risk/score", json=test_request)
    assert response.status_code == 200
    data = response.json()
    assert "risk_score" in data
    assert "confidence" in data
    assert "factors" in data
    assert "id" in data
    assert data["entity_name"] == "Test Corp"
    assert data["factors"] == ["industry", "location"]

client = TestClient(app)

def test_health_endpoint():
    response = client.get("/health")
    assert response.status_code == 200
    assert response.json() == {"status": "healthy"}

def test_risk_score_endpoint():
    test_request = {
        "entity_name": "Test Corp",
        "risk_factors": ["industry", "location"],
        "context": "Test context"
    }
    response = client.post("/risk/score", json=test_request)
    assert response.status_code == 200
    data = response.json()
    assert "risk_score" in data
    assert "confidence" in data
    assert "factors" in data
    assert "id" in data
    assert data["entity_name"] == "Test Corp"
    assert data["factors"] == ["industry", "location"]